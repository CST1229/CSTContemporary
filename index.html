<!DOCTYPE html>
<html>
<head>
	<title>CST Cont.</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1"> 
	<link rel="icon" href="./assets/icon.ico">
</head>

<style>
	body {
		background: #050530;
		color: white;
	}
</style>

<center id="gameContainer">
	<noscript>you need javascript!</noscript>
	<canvas width="800" height="600" id="canvas">game</canvas>
</center>

<script>
	const DEBUG = true;
	let timeScale = 1;
		
	// the game itself
	
	// Assets and constants
	// (filled in by the loader)
	
	/**
	 * Representation of a sprite, with support for pulling out from spritesheets.
	 */
	class SpriteDef {
		image = null;
		imageX = 0;
		imageY = 0;
		imageWidth = 0;
		imageHeight = 0;
		
		originX = 0;
		originY = 0;
		
		// The size and origin of the sprite's "canvas"; the uncropped region of the sprite.
		canvasWidth = 0;
		canvasHeight = 0;
		canvasOriginX = 0;
		canvasOriginY = 0;
		
		data = Object.create(null);
		
		constructor(image, ogx = 0, ogy = 0, w = 0, h = 0) {
			this.image = image;
			this.imageWidth = image.naturalWidth;
			this.imageHeight = image.naturalHeight;
			this.canvasWidth = w || image.naturalWidth;
			this.canvasHeight = h || image.naturalHeight;
			this.originX = ogx || 0;
			this.originY = ogy || 0;
			this.canvasOriginX = ogx || 0;
			this.canvasOriginY = ogy || 0;
		}
	}
	
	/**
	 * Representation of an Aseprite tag.
	 */
	class SpriteSheetTagDef {
		/**
		 * The name of this tag.
		 * Empty tags represent all frames in the sprite.
		 */
		name = "";
		frames = [];
		repeat = Infinity;
		
		get length() {
			return this.frames.length;
		}
		set length(val) {
			this.frames.length = val;
		}
		
		constructor(name, repeat) {
			this.name = name;
			if (isNaN(repeat)) {
				this.repeat = Infinity;
			} else {
				this.repeat = Number(repeat);
			}
		}
		
		addFrame(asset) {
			this.frames.push(asset);
		}
		getFrame(frameNo) {
			if (this.length === 0) throw new Error(`Tag ${name} has 0 length`);
			return this.frames[frameNo];
		}
		/**
		 * Get a frame from this tag, accounting for looping, etc..
		 */
		getFrameRepeat(frameNo) {
			if (this.length === 0) throw new Error(`Tag ${name} has 0 length`);
			frameNo = Math.floor(+frameNo);
			if (frameNo < 0) return this.getFrameRepeat(0 - frameNo);
			const repeatNo = frameNo / this.length;
			// Repeating has ended, so just return the last frame
			if (repeatNo >= this.repeat) return this.frames[this.length - 1];
			return this.frames[frameNo % this.length];
		}
		/**
		 * Returns whether the frame number is past the end of this tag or not.
		 * Always returns false for infinitely looping tags.
		 */
		isFrameEnd(frameNo) {
			if (this.length === 0) throw new Error(`Tag ${name} has 0 length`);
			frameNo = Math.floor(+frameNo);
			if (frameNo < 0) return this.isFrameEnd(0 - frameNo);
			const repeatNo = frameNo / this.length;
			// Repeating has ended, so just return the last frame
			if (repeatNo >= this.repeat) return true;
			return false;
		}
	}
	/**
	 * Representation of an Aseprite-based animation.
	 */
	class SpriteSheetDef {
		name = "";
		tags = Object.create(null);
		
		defineTag(name, repeat = Infinity) {
			this.tags[name] = new SpriteSheetTagDef(name, repeat);
		}
		checkTag(name) {
			if (!this.tags[name]) throw new Error(`Tag ${name} does not exist in ${this.name}`);
			return this.tags[name];
		}
		getTag(name) {
			return this.tags[name];
		}
		hasTag(name) {
			return !!this.tags[name];
		}
	}
	
	const assets = {
		player: {sheet: "sheets/player"},
		errortile: 0,
		tile0: 0,
		peterplatform: 0,
	};
	let tiles, tile, tilesIndexed, MAX_TILES;
	
	function getSprite(img) {
		if (typeof img === "string" && assets[img]) img = assets[img];
		return img;
	}
	function drawSprite(ctx, img, x, y, scaleX = 1, scaleY = 1, rotate = 0) {
		ensureType(ctx, "ctx", CanvasRenderingContext2D);
		const spr = getSprite(img);
		if (!spr.image) throw new Error(`Sprite ${spr} not found`);
		
		// image x/y/w/h
		const ix = spr.imageX;
		const iy = spr.imageY;
		const iw = spr.imageWidth;
		const ih = spr.imageHeight;
		// target x/y/w/h
		const tx = x - spr.originX;
		const ty = y - spr.originY;
		const tw = spr.imageWidth;
		const th = spr.imageHeight;
		
		ctx.save();
		ctx.scale(scaleX, scaleY);
		ctx.rotate(rotate);
		ctx.drawImage(
			spr.image, ix, iy, iw, ih, tx, ty, tw, th
		);
		ctx.restore();
	}
	
	
	
	// utility functions
	const flr = Math.floor;
	const flrto = function(val, to) {
		return flr(val / to) * to;
	};
	const approach = function(from, to, rate) {
		if (from > to) return Math.max(from - rate, to);
		return Math.min(from + rate, to);
	};
	const sign = function(val) {
		return val > 0 ? 1 : (val < 0 ? -1 : 0);
	};
	const oscillate = function(from, to, period, timer) {
		return from + (-Math.cos(timer * Math.PI / period) + 1) / 2 * (to - from);
	};
	const oscillateFromCenter = function(from, to, period, timer) {
		return from + (Math.sin(timer * Math.PI / period) + 1) / 2 * (to - from);
	};
	const clamp = (val, min, max) => Math.max(min, Math.min(val, max));
	const ceil = Math.ceil;
	
	function ensureType(obj, name, type, allowFalsy = false) {
		let failed = false;
		let typeName = "UNKNOWN";
		if (typeof type === "string" && (typeof obj !== type)) {
			failed = true;
			typeName = type;
		} else if (typeof type === "function" && !(obj instanceof type)) {
			failed = true;
			typeName = type.name;
		}
		if (failed) {
			const falsyMsg = allowFalsy ? " or falsy" : "";
			console.error(`ensureType: ${name} must be a ${typeName}${falsyMsg}, got:`, obj);
			throw new TypeError(`${name} must be a ${typeName}${falsyMsg}, got ${typeof obj} ${obj}`);
		}
	}
	
	
	// Canvas stuff
	const gameContainer = document.getElementById("gameContainer");
	const canv = document.getElementById("canvas");
	const sw = 640;
	const sh = 480;
	let gameScale = 1;
	let gameScaleInverse = 1;
	canv.style.background = "black";
	
	const ctx = canv.getContext("2d");
	let resizedThisFrame = false;
	function resizeGame() {
		if (resizedThisFrame) return;
		const w = window.innerWidth;
		const h = window.innerHeight;
		if (w / h > sw / sh) {
			gameScale = Math.max(h / sh, 1);
			canv.style.width = "auto";
			canv.style.height = "100%";
		} else {
			gameScale = Math.max(w / sw, 1);
			canv.style.width = "100%";
			canv.style.height = "auto";
		}
		gameScale *= window.devicePixelRatio || 1;
		resizedThisFrame = true;
		canv.width = ceil(sw * gameScale);
		canv.height = ceil(sh * gameScale);
		draw();
		ctx.msImageSmoothingEnabled = false;
		ctx.imageSmoothingEnabled = false;
		gameScaleInverse = 1 / gameScale;
	}
	
	
	// Input
	const buttons = new Set();
	const buttonsJust = new Set();
	const modernKeyToIEKey = {
		arrowup: "up",
		arrowdown: "down",
		arrowleft: "left",
		arrowright: "right",
		" ": "spacebar",
		escape: "esc",
		
		// screw it i'll add wasd mappings here
		w: "up",
		a: "left",
		s: "down",
		d: "right",
	};
	const ignoreKeys = {
		"tab": true,
		"f1": true,
		"f2": true,
		"f3": true,
		"f4": true,
		"f5": true,
		"f6": true,
		"f7": true,
		"f8": true,
		"f9": true,
		"f10": true,
		"f11": true,
		"f12": true,
	};
	document.onkeydown = function(e) {
		const _key = e.key.toLowerCase();
		const key = modernKeyToIEKey[_key] || _key;
		if (!document.activeElement || (document.activeElement.tagName !== "BODY" && document.activeElement.tagName !== "CANVAS" && document.activeElement.tagName !== "HTML") || ignoreKeys[key]) return;
		if (!pressed(key)) buttonsJust.add(key);
		buttons.add(key);
		if (!e.ctrlKey && !e.altKey) e.preventDefault();
	};
	document.onkeyup = function(e) {
		const _key = e.key.toLowerCase();
		const key = modernKeyToIEKey[_key] || _key;
		buttons.delete(key);
	};
	const pressed = buttons.has.bind(buttons);
	const justPressed = buttonsJust.has.bind(buttonsJust);
	
	let mouseX = null;
	let mouseY = null;
	function updateMouse(e) {
		const canvasRect = canvas.getBoundingClientRect();
		mouseX = flrto((e.clientX - canvasRect.x) / canvasRect.width * sw, 0.0001);
		mouseY = flrto((e.clientY - canvasRect.y) / canvasRect.height * sh, 0.0001);
		
		const lmb = e.buttons & 0b1;
		const rmb = e.buttons & 0b10;
		const mmb = e.buttons & 0b100;
		if (lmb && !buttons.has("lmb")) buttonsJust.add("lmb");
		if (rmb && !buttons.has("rmb")) buttonsJust.add("rmb");
		if (mmb && !buttons.has("mmb")) buttonsJust.add("mmb");
		buttons[lmb ? "add" : "delete"]("lmb");
		buttons[rmb ? "add" : "delete"]("rmb");
		buttons[mmb ? "add" : "delete"]("mmb");
	}
	window.addEventListener("mousedown", updateMouse);
	window.addEventListener("mouseup", updateMouse);
	window.addEventListener("mousemove", updateMouse);
	canvas.addEventListener("contextmenu", (e) => e.preventDefault());
	
	
	// Level generation
	// fill an array
	function fill(arr, val) {
		for (let i = 0; i < arr.length; i++) arr[i] = val;
		return arr;
	}
	const TILE_SIZE = 32;
	const GEN_FACTOR = 300;
	const GEN_YOFF = 400;
	
	let editor = false;
	let tmh = 200; // tilemap height
	let tmw = 150; // tilemap width
	let tilemap;
	let gameLength = "Medium";
	function genLevel(type) {
		if (type === "random") {
			tilemap = fill(new Array(tmh)).map(function(v, i) {
				return fill(new Array(tmw)).map(function() {
					if (i > 0) return Math.floor(Math.random() * (i + GEN_YOFF) / GEN_FACTOR) ? tile.tile : tile.none;
					return tile.none;
				});
			});
			tilemap[0][0] = tile.obj_player;
		} else if (type === "flat") {
			tilemap = fill(new Array(tmh)).map(function(v, i) {
				return fill(new Array(tmw)).map(function() {
					if (i < (tmh - 1)) return tile.none;
					return tile.tile;
				});
			});
			tilemap[tmh - 2][1] = tile.obj_player;
		} else
			tilemap = fill(new Array(tmh)).map(function(v, i) {
				return fill(new Array(tmw), tile.none);
			});
	}
	const lengthHeights = {
		Tiny: 50,
		Short: 100,
		Medium: 200,
		Long: 250,
		XL: 300,
	};
	const gameTimes = {
		Tiny: 10,
		Short: 30,
		Medium: 70,
		Long: 100,
		XL: 135,
	};
	const gameLengths = Object.keys(lengthHeights);
	
	
	// Level storage
	let levels = [];
	try {
		const levArr = JSON.parse(localStorage.getItem("levels"));
		if (Array.isArray(levArr)) levels = levArr;
	} catch(e) {}
	
	if (!localStorage.getItem("levels")) {
		fetch("./assets/levels.json").then((res) => res.json()).then((arr) => {
			levels.push(...arr);
		});
	}
	
	function saveLevels() {
		saveLevel();
		localStorage.setItem("levels", JSON.stringify(levels));
	}
	let level = null;
	function saveLevel() {
		if (!level || !tilemap) return;
		level.tilemap = structuredClone(tilemap);
	}
	function loadLevel(lvl) {
		level = lvl;
		tmh = lvl.tilemap.length;
		tmw = (lvl.tilemap[0] || []).length;
		tilemap = structuredClone(lvl.tilemap);
	}
	
	// Tile utils
	// world x, world y
	function tileAt(wx, wy, oobTile) {
		const tx = flr(wx / TILE_SIZE);
		const ty = flr(wy / TILE_SIZE);
		return getTile(tx, ty, oobTile);
	}
	function tileInBounds(tx, ty) {
		if (ty < 0 || ty >= tmh) return false;
		if (tx < 0 || tx >= tmw) return false;
		return true
	}
	function getTile(tx, ty, oobTile) {
		if (!tileInBounds(tx, ty)) return oobTile;
		return tilemap[ty][tx];
	}
	function setTile(tx, ty, tile) {
		if (!tileInBounds(tx, ty)) return undefined;
		return tilemap[ty][tx] = tile;
	}
	
	
	// Objects
	const objs = [];
	function deleteAllObjs() {
		objs.forEach(o => {
			if (o.dispose) o.dispose();
		});
		objs.length = 0;
	}
	function deleteObj(o) {
		if (o.dispose) o.dispose();
		const index = objs.indexOf(o);
		if (index >= 0) objs.splice(index, 1);
	}
	
	const collideInclude = {
		NONE: 0,
		TILES: 0b1,
		OBJECTS: 0b10,
		SOLID_OBJECTS: 0b100,
		ALL: 0b111,
		SOLIDS: 0b101,
	};
	
	function checkCollision(x, y, exclude = null, include = collideInclude.NONE) {
		if ((include & collideInclude.TILES) && tileAt(x, y, tile.unbreakable)) return true;
		if (include & collideInclude.OBJECTS) {
			for (const o of objs) {
				if (exclude === o) continue;
				if (!o.isHitboxObj) continue;
				if (!(include & collideInclude.SOLID_OBJECTS) && o.solid) continue;
				if (!(include & collideInclude.OBJECTS) && !o.solid) continue;
				if (x >= o.x && y >= o.y && x < (o.x + o.w) && y < (o.y + o.h)) return true;
			}
		}
		return false;
	}
	function AABBLineCheck(x, w, ox, ow) {
		return x < ox+ow && x+w > ox;
	}
	function AABBCheck(x, y, w, h, ox, oy, ow, oh) {
		return AABBLineCheck(x, w, ox, ow) && AABBLineCheck(y, h, oy, oh);
	}
	function getHitboxCollisions(x, y, w, h, exclude = null, nonSolids = false) {
		const collisions = [];
		for (const o of objs) {
			if (exclude === o) continue;
			if (!o.isHitboxObj) continue;
			if (!nonSolids && !o.solid) continue;
			if (AABBCheck(x, y, w, h, o.x, o.y, o.w, o.h)) collisions.push(o);
		}
		return collisions;
	}
	
	class Obj {
		// apparently instanceof is slow, so optimize
		isHitboxObj = false;
	}
	class HitboxObj extends Obj {
		isHitboxObj = true;
		
		x = 0;
		y = 0;
		w = 0;
		h = 0;
		solid = false;
	}
	class CollideObj extends HitboxObj {
		hsp = 0;
		vsp = 0;
		
		hitsTiles = true;
		hitsObjects = true;
		
		moveY(dt, {onHitFloor = ()=>{}, onHitCeiling = ()=>{}}) {
			this.y += this.vsp * dt;
			const oldVsp = this.vsp;
			if (this.hitsTiles) {
				if (this.vsp > 0 && (
					tileAt(this.x, this.y + this.h, tile.unbreakable) ||
					tileAt(this.x + this.w - 0.01, this.y + this.h, tile.unbreakable)
				)) {
					this.y = flrto(this.y + this.h, TILE_SIZE) - this.h;
					this.vsp = 0;
					onHitFloor.call(this, oldVsp);
				} else if (this.vsp < 0 && tileAt(this.x + this.w/2, this.y, tile.unbreakable)) {
					this.y = flrto(this.y, TILE_SIZE) + TILE_SIZE;
					this.vsp = 0;
					onHitCeiling.call(this, oldVsp);
				}
			}
			if (this.hitsObjects && oldVsp != 0) {
				
				if (oldVsp > 0) {
					const colls = getHitboxCollisions(this.x, this.y, this.w, this.h, this, false);
					for (const obj of colls) {
						if (obj.y < (this.y + this.h)) {
							this.y = obj.y - this.h;
							this.vsp = 0;
							onHitFloor.call(this, oldVsp);
						}
					}
				} else if (oldVsp < 0) {
					const colls = getHitboxCollisions(this.x, this.y, this.w, this.h, this, false);
					for (const obj of colls) {
						if ((obj.y + obj.h) > this.y) {
							this.y = obj.y + obj.h;
							this.vsp = 0;
							onHitCeiling.call(this, oldVsp);
						}
					}
				}
			}
		}
		
		moveX(dt, {onHitWall = ()=>{}}) {
			this.x += this.hsp * dt;
			const oldHsp = this.hsp;
			if (this.hitsTiles) {
				if (this.hsp <= 0 && tileAt(this.x, this.y + this.h/2, tile.unbreakable)) {
					this.x = flrto(this.x, TILE_SIZE) + TILE_SIZE;
					this.hsp = 0;
					onHitWall.call(this, oldHsp, "left");
				} else if (this.hsp >= 0 && tileAt(this.x + this.w, this.y + this.h/2, tile.unbreakable)) {
					this.x = flrto(this.x + this.w, TILE_SIZE) - this.w;
					this.hsp = 0;
					onHitWall.call(this, oldHsp, "right");
				}
			}
			/*
			if (this.hitsObjects && oldHsp != 0) {
				if (oldHsp > 0) {
					const colls = getHitboxCollisions(this.x, this.y, this.w, this.h, this, false);
					for (const obj of colls) {
						if (obj.x < (this.x + this.w)) {
							this.x = obj.x - this.w;
							this.hsp = 0;
							onHitWall.call(this, oldHsp, "right");
						}
					}
				} else if (oldHsp < 0) {
					const colls = getHitboxCollisions(this.x, this.y, this.w, this.h, this, false);
					for (const obj of colls) {
						if ((obj.x + obj.w) > this.x) {
							this.x = obj.x + obj.w;
							this.hsp = 0;
							onHitWall.call(this, oldHsp, "left");
						}
					}
				}
			}
			*/
		}
		move(dt, callbacks = {}) {
			this.moveX(dt, callbacks);
			this.moveY(dt, callbacks);
		}
	}
	class Player extends CollideObj {
		facing = 1;
		falling = 0;
		jumpBuffer = 0;
		storedBlock = 0;
		
		prevFacing = this.facing;
		prevStoredBlock = this.storedBlock;
		
		w = 24;
		h = 24;
		solid = true;
		
		grav = 1200;
		accel = 800;
		decel = 3000;
		friction = 800;
		jumpSpeed = -500;
		maxSpeed = 300;
		coyoteTime = 0.2;
		
		sprite = assets.player;
		animation = "stand";
		frame = 0;
		
		spawnAt(x, y) {
			this.x = x + (32 - this.w) / 2;
			this.y = y + TILE_SIZE - this.h;
		}
		
		step(dt) {
			const joystickX = pressed("right") - pressed("left");
			
			if (joystickX !== 0) {
				if (joystickX === -sign(this.hsp))
					this.hsp += joystickX * this.decel * dt;
				else
					this.hsp += joystickX * this.accel * dt;
				this.facing = joystickX;
			} else
				this.hsp = approach(this.hsp, 0, this.friction * dt);
			
			this.vsp += this.grav * dt;
			this.hsp = Math.min(Math.max(this.hsp, -this.maxSpeed), this.maxSpeed);
			
			this.falling += dt;
			this.move(dt, {
				onHitFloor() {
					this.falling = 0;
				},
			});
			
			if (justPressed("up")) this.jumpBuffer = 0.1;
			if (this.falling <= this.coyoteTime && this.jumpBuffer > 0) {
				this.falling = 999;
				this.jumpBuffer = 0;
				this.vsp = this.jumpSpeed;
			}
			this.jumpBuffer = approach(this.jumpBuffer, 0, dt);
			
			
			if (justPressed("spacebar")) {
				const collX = this.x + this.w/2;
				const collY = this.y + this.h/2;
				const tx = flr(collX / TILE_SIZE);
				const ty = ceil(collY / TILE_SIZE);
				const blockBoost = DEBUG && pressed("down");
				if (this.storedBlock > 0) {
					const collisionBelow = checkCollision(collX, collY + TILE_SIZE, this, collideInclude.SOLIDS);
					if (!collisionBelow || (blockBoost && getTile(tx, ty, tile.unbreakable) != tile.unbreakable)) {
						if (blockBoost && getTile(tx, ty, tile.unbreakable)) {
							setTile(tx, ty, tile.none);
							this.vsp = this.jumpSpeed * Math.sqrt(2);
						} else
							setTile(tx, ty, this.storedBlock);
						this.storedBlock = 0;
					} else if (!checkCollision(collX, collY, this, collideInclude.SOLIDS) && !checkCollision(collX, collY-TILE_SIZE, this, collideInclude.SOLIDS)) {
						setTile(tx, ty - 1, this.storedBlock);
						this.storedBlock = 0;
						// snap to the block we just placed
						this.y = (ty - 1) * TILE_SIZE - this.h;
					}
				} else if (this.falling == 0) {
					const tl = getTile(tx, ty);
					if (tl && tl != tile.unbreakable) {
						this.storedBlock = tl;
						setTile(tx, ty, tile.none);
						this.falling = 999;
					}
				}
			}
			
			camX = this.x + this.w/2 - sw/2;
			camY = this.y + this.h/2 - sh/2;
			
			if (this.y >= (tmh * TILE_SIZE - this.h)) {
				deleteObj(this);
				objs.push(new WinText());
			}
			
			this.doAnimation(dt);
		}
		
		doAnimation(dt) {
			let anim = this.animation;
			let animFPS = 0;
			
			let specialAnims = false;
			if (anim === "turn") {
				animFPS = 1000 / 80;
				if (!this.animEnded()) {
					specialAnims = true;
				}
			} if (anim === "pickup" || anim === "putdown") {
				animFPS = 1000 / 33;
				if (!this.animEnded()) {
					specialAnims = true;
				}
			}
			if (!specialAnims) {
				if (this.falling <= this.coyoteTime) {
					if (Math.abs(this.hsp) <= 10) {
						anim = "stand";
						animFPS = 1000 / 200;
					} else {
						anim = "walk";
						animFPS = 1000 / 80;
					}
				} else {
					animFPS = 1000 / 50;
					if (this.vsp >= 0) {
						anim = "fall";
					} else {
						anim = "jump";
					}
				}
			}
			
			if (this.prevStoredBlock !== this.storedBlock) {
				anim = this.storedBlock ? "pickup" : "putdown";
				this.prevStoredBlock = this.storedBlock;
			} else if (this.prevFacing !== this.facing && anim !== "pickup" && anim !== "putdown") {
				if (this.falling <= this.coyoteTime) {
					anim = "turn";
				}
				this.prevFacing = this.facing;
			}
			
			if (anim !== this.animation) {
				this.animation = anim;
				this.frame = 0;
			} else {
				this.frame += dt * animFPS;
			}
		}
		
		getAnimTag() {
			let suffix = "_" + (this.facing === 1 ? "r" : "l") + (this.storedBlock ? "c" : "");
			return this.sprite.getTag(this.animation + suffix) || this.sprite.getTag(this.animation);
		}
		animEnded() {
			return this.getAnimTag().isFrameEnd(this.frame);
		}
		
		drawStoredBlock(ctx, frame) {
			if (this.storedBlock) {
				const tx = -4;
				const ty = -frame.canvasOriginY + frame.data.blockOffset + 2;
				drawSprite(ctx, tileGraphic(this.storedBlock), tx, ty);
			}
		}
		draw(ctx) {
			const frame = this.getAnimTag().getFrameRepeat(this.frame);
			const blockInFront = this.animation === "pickup";
			
			if (!blockInFront) this.drawStoredBlock(ctx, frame);
			drawSprite(ctx, frame, 0, 0);
			if (blockInFront) this.drawStoredBlock(ctx, frame);
		}
	}
	class PeterPlatform extends CollideObj {
		solid = true;
		hitsTiles = true;
		hitsObjects = true;
		
		startX = 0;
		startY = 0;
		timer = 0;
		
		w = 32 * 3;
		h = 32;
		
		moveX = 0;
		moveY = 32 * -5;
		moveTime = 3;
		
		spawnAt(x, y) {
			this.x = x;
			this.y = y;
			this.startX = this.x;
			this.startY = this.y;
		}
		
		step(dt) {
			this.timer += dt;
			this.y = oscillate(this.startY, this.startY + this.moveY, this.moveTime, this.timer);
		}
		draw(ctx) {
			drawSprite(ctx, assets.peterplatform, 0, 0);
		}
	}
	
	function WinText() {
		this.drawGUI = function(ctx) {
			ctx.fillStyle = "white";
			ctx.textAlign = "center";
			ctx.textBaseline = "top";
			ctx.font = "bold 64px sans-serif";
			
			ctx.fillText(
				"You Have Not Win!",
				sw/2, sh/2-48
			);
			ctx.font = "32px sans-serif";
			ctx.fillText(
				"(You... DIED!!!)",
				sw/2, sh/2+16
			);
		};
	}
	function Playtest() {
		this.step = function() {
			if (justPressed("0")) {
				queueMicrotask(() => {
					editor = true;
					loadLevel(level);
					startGame();
				});
			}
		};
	}
	function Editor() {
		let scrolledX = 0;
		let scrolledY = 0;
		let lastMouseX = mouseX;
		let lastMouseY = mouseY;
		let couldPick = false;
		
		let brush = tile.tile;
		
		// 2-finger touch scrolling, mainly
		function onScroll(e) {
			if (paused) return;
			e.preventDefault();
			scrolledX += e.deltaX / gameScale;
			scrolledY += e.deltaY / gameScale;
		}
		canvas.addEventListener("wheel", onScroll);
		
		const moveSpeed = TILE_SIZE * 15;
		this.step = function(dt) {
			const joystickX = pressed("right") - pressed("left");
			const joystickY = pressed("down") - pressed("up");
			camX += joystickX * dt * moveSpeed + scrolledX;
			camY += joystickY * dt * moveSpeed + scrolledY;
			if (justPressed("mmb")) couldPick = true;
			if (mouseX != null && mouseY != null && pressed("mmb")) {
				if (lastMouseX - mouseX != 0 || lastMouseY - mouseY != 0) couldPick = false;
				camX += lastMouseX - mouseX;
				camY += lastMouseY - mouseY;
			}
			[camX, camY] = getClampedCameraPos(false);
			scrolledX = 0;
			scrolledY = 0;
			lastMouseX = mouseX;
			lastMouseY = mouseY;
			
			if (justPressed("1")) brush--;
			if (justPressed("2")) brush++;
			brush = clamp(brush, 0, MAX_TILES);
			
			if (mouseX != null) {
				if (pressed("lmb") || pressed("rmb")) {
					couldPick = false;
					const tl = pressed("rmb") ? tile.none : brush;
					const [cx, cy] = getClampedCameraPos();
					const tx = flr((cx + mouseX) / TILE_SIZE);
					const ty = flr((cy + mouseY) / TILE_SIZE);
					setTile(tx, ty, tl);
				} else if (!pressed("mmb") && couldPick) {
					couldPick = false;
					const [cx, cy] = getClampedCameraPos();
					const tx = flr((cx + mouseX) / TILE_SIZE);
					const ty = flr((cy + mouseY) / TILE_SIZE);
					brush = getTile(tx, ty, brush);
				}
			}
			
			if (justPressed("0")) {
				queueMicrotask(() => {
					editor = false;
					saveLevels();
					startGame(true);
				});
			}
		};
		
		this.draw = function() {
			if (paused) return;
			if (mouseX != null && !pressed("rmb") && !pressed("lmb") && !pressed("mmb")) {
				const [cx, cy] = getClampedCameraPos();
				const tx = flr((cx + mouseX) / TILE_SIZE);
				const ty = flr((cy + mouseY) / TILE_SIZE);
				ctx.globalAlpha = 0.5;
				drawSprite(ctx, tileGraphic(brush), tx * TILE_SIZE, ty * TILE_SIZE);
			}
		};
		
		this.dispose = function() {
			canvas.removeEventListener("scroll", onScroll);
		};
	}
	
	function getClampedCameraPos(rounded = true) {
		const borderW = editor ? sw/2 : 0;
		const borderH = editor ? sh/2 : 0;
		
		let eCamX = Math.min(camX, Math.max(tmw * TILE_SIZE - sw, 0) + borderW);
		let eCamY = Math.min(camY, Math.max(tmh * TILE_SIZE - sh, 0) + borderH);
		if (rounded) {
			eCamX = flrto(eCamX, gameScaleInverse);
			eCamY = flrto(eCamY, gameScaleInverse);
		}
		eCamX = Math.max(eCamX, -borderW);
		eCamY = Math.max(eCamY, -borderH);
		return [eCamX, eCamY];
	}
	
	function tileGraphic(tile) {
		return assets["tile" + tile] || assets.errortile;
	}
	
	// actual tile loading since classes aren't hoisted
	tiles = {
		none: {name: "Air"},
		tile: {name: "Stone Block"},
		unbreakable: {name: "Cobalt Block"},
		gold: {name: "Gold Block"},
		obj_player: {name: "Player Start", object: Player},
		obj_peterplatform: {name: "Peter Platform", object: PeterPlatform},
	};
	tile = Object.fromEntries(Object.entries(tiles).map(([key], i) => [key, i]));
	tilesIndexed = Object.fromEntries(Object.entries(tiles).map(([key, value], i) => [i, value]));
	MAX_TILES = Math.max(...Object.values(tile));
	for (let i = 1; i <= MAX_TILES; i++) {
		assets["tile" + i] = 0;
	}
	
	let camX = 0;
	let camY = 0;
	let loading = true;
	function draw(dt) {
		if (loading) return drawLoadingScreen();
		ctx.save();
		ctx.scale(gameScale, gameScale);
		ctx.clearRect(0, 0, sw, sh);
		ctx.save();
		try {
			// effective camera position
			const [eCamX, eCamY] = getClampedCameraPos();
			ctx.translate(-eCamX, -eCamY);
			
			// level border
			if (editor && !onTitle) {
				ctx.fillStyle = "#000";
				ctx.globalAlpha = 0.25;
				
				const bw = sw*2;
				const bh = sh*2;
				ctx.fillRect(-bw, -bh, bw, tmh * TILE_SIZE + bh * 2); // left
				ctx.fillRect(0, -bh, tmw * TILE_SIZE, bh);  // top
				ctx.fillRect(tmw * TILE_SIZE, -bh, bw, tmh * TILE_SIZE + bh * 2); // right
				ctx.fillRect(0, tmh * TILE_SIZE, tmw * TILE_SIZE, bh);  // bottom
				
				ctx.globalAlpha = 1;
			}
			
			// tilemap
			ctx.fillStyle = "#448";
			let minx = flr(eCamX / TILE_SIZE, gameScaleInverse), maxx = minx + ceil(sw / TILE_SIZE) + 1;
			for (let miny = flr(eCamY / TILE_SIZE, gameScaleInverse), y = miny, maxy = miny + ceil(sh / TILE_SIZE) + 1 ; y < maxy; y++) {
				if (!tilemap[y]) continue;
				for (let x = minx; x < maxx; x++) {
					if (tilemap[y][x])
						drawSprite(ctx, tileGraphic(tilemap[y][x]), x * TILE_SIZE, y * TILE_SIZE)
				}
			}
			
			objs.forEach(function(obj) {
				if (obj.draw) {
					ctx.save();
					if ("x" in obj) ctx.translate(+obj.x, +obj.y)
					obj.draw(ctx);
					ctx.restore();
				}
			});
		} catch(e) {
			throw e;
		} finally {
			ctx.restore();
			objs.forEach(function(obj) {
				if (obj.drawGUI) {
					ctx.save();
					obj.drawGUI(ctx);
					ctx.restore();
				}
			});
		}
		if (paused) {
			drawPause();
		}
		if (DEBUG) {
			ctx.fillStyle = "white";
			ctx.textAlign = "left";
			ctx.textBaseline = "top";
			ctx.font = "11px sans-serif";
			const fps = (1 / dt).toFixed(1);
			ctx.fillText(
				"DEBUG - fps: " + fps,
				2, 2
			);
		}
		ctx.restore();
	}
	
	let lastT = 0;
	const maxDelta = 1 / 10;
	function step(t) {
		const dt = Math.min((t - lastT) / 1000, maxDelta) * timeScale;
		lastT = t;
		
		if (paused) {
			stepPause();
		} else {
			objs.forEach(function(obj) {
				if (obj.step) obj.step(dt);
			});
			if (justPressed("enter") || justPressed("esc")) enterPause();
		}
		draw(dt);
		buttonsJust.forEach(function(bt) {
			buttonsJust.delete(bt);
		});
		requestAnimationFrame(step);
		resizedThisFrame = false;
	}
	
	
	let paused = false;
	let pauseMenus = [];
	function Menu(menu = []) {
		/**
		 * The index of the currently selected item in the menu.
		 */
		this.index = 0;
		/**
		 * If true, this menu can't be escaped with Esc (normally selects the bottommost item).
		 */
		this.inescapable = false;
		/**
		 * All items of this menu.
		 */
		this.items = [];
		/**
		 * The original object used to define this menu (can be either a function or array).
		 */
		this.definition = null;
		
		if (menu.items) {
			// this is a menu object
			Object.assign(this, menu);
		} else {
			this.items = menu;
		}
	}
	function pauseSubmenu(items = []) {
		if (!paused) pauseMenus.length = 0;
		paused = true;
		
		const oldItems = items;
		
		if (items instanceof Function) items = items();
		for (let i = 0; i < items.length; i++) {
			if (items[i].length < 3) items[i][2] = {};
		}
		const menu = new Menu(items);
		menu.definition = oldItems;
		pauseMenus.push(menu);
		return menu;
	}
	
	const MenuOption = {
		back: ["Back"],
		gameLength: [() => "Game Length: " + gameLength, () => {
			let index = gameLengths.indexOf(gameLength) + 1;
			if (index >= gameLengths.length) index = 0;
			gameLength = gameLengths[index];
			return true;
		}],
		levels: [() => onTitle ? "Level Editor..." : "Levels...", () => {
			if (editor) saveLevels();
			return pauseSubmenu(Menu.levels);
		}],
		stoneSimulator: ["Stone Simulator...", () => pauseSubmenu([MenuOption.back, MenuOption.gameLength])],
	}
	
	Menu.title = {inescapable: true, items: [
		/*["Start", () => {
			editor = false;
			startGame();
		}],*/
		["Start First Level", () => {
			if (!levels[0]) return true;
			editor = false;
			loadLevel(levels[0]);
			startGame();
		}],
		MenuOption.levels,
		//MenuOption.stoneSimulator,
		["Options...",
			() => pauseSubmenu([
				MenuOption.back,
				["Download All Levels", () => {
					const url = URL.createObjectURL(new Blob([localStorage.getItem("levels")]));
					const a = document.createElement("a");
					a.href = url;
					a.download = "levels.json";
					a.click();
					setTimeout(1000, () => URL.revokeObjectURL(url));
					return true;
				}],
				["Made by CST1229", () => {
					setTimeout(() => {
						window.open("https://cst1229.eu.org/", "_blank", "noopener,noreferrer");
					}, 100);
					return true;
				}],
				["Source Code", () => {
					setTimeout(() => {
						window.open("https://github.com/CST1229/CSTContemporary/", "_blank", "noopener,noreferrer");
					}, 100);
					return true;
				}],
				["Play CST Stone Simulator!", () => {
					setTimeout(() => {
						window.open("https://cst1229.github.io/StoneSimulator", "_blank", "noopener,noreferrer");
					}, 100);
					return true;
				}],
			]),
		],
		["What am I doing???", () => {
			setTimeout(() => {
				window.open("https://github.com/CST1229/CSTContemporary/commits", "_blank", "noopener,noreferrer");
			}, 100);
			return true;
		}],
		["Quit", () => {
			window.close();
		}],
	]};
	Menu.pause = [
		["Continue"],
		/*["New Game", () => {
			startGame();
		}],*/
		["Edit (0)", () => {
			editor = true;
			loadLevel(level);
			startGame();
		}],
		MenuOption.levels,
		//MenuOption.stoneSimulator,
		["Exit", () => {
			titleScreen();
			return true;
		}],
	];
	Menu.pauseEditor = [
		["Continue"],
		["Playtest (0)", () => {
			editor = false;
			saveLevels();
			startGame(true);
		}],
		["Level Properties...", () => pauseSubmenu([
				MenuOption.back,
				[() => ("Level Name: " + ((level && level.name) ? level.name : "WHAT")), () => {
					const name = prompt("Name?", level.name);
					if (!name) return true;
					level.name = name;
					saveLevels();
					return true;
				}],
				["Resize Level", () => {
					const w = flr(+(prompt("Width...", tmw)) || 0);
					if (w <= 0 || !isFinite(w)) return true;
					const h = flr(+(prompt("Height...", tmh)) || 0);
					if (h <= 0 || !isFinite(h)) return true;
					if (h > tmh) {
						for (let i = tmh; i < h; i++) tilemap.push(fill(new Array(tmw), tile.none));
					} else if (h < tmh) {
						for (let i = tmh; i > h; i--) tilemap.pop();
					}
					if (w > tmw) {
						for (let i = tmw; i < w; i++) tilemap.forEach(t => t.push(tile.none));
					} else if (w < tmw) {
						for (let i = tmw; i > w; i--) tilemap.forEach(t => t.pop());
					}
					tmw = w;
					tmh = h;
					return true;
				}],
				["Clear Level", () => {
					if (confirm("Are you sure you want to clear this level?")) {
						genLevel();
						startGame();
					}
					return true;
				}],
				["Delete Level", () => {
					if (confirm("Are you sure you want to delete this level?")) {
						levels.splice(levels.indexOf(level), 1);
						level = null;
						saveLevels();
						titleScreen();
						return "back";
					}
					return true;
				}],
			]),
		],
		MenuOption.levels,
		["Exit", () => {
			saveLevels();
			titleScreen();
			return "back";
		}],
	];
	Menu.levels = () => {
		function levelItem(l) {
			return [l.name, () => {
				editor = true;
				loadLevel(l);
				startGame();
				exitPause();
			}, {
				onSort(index, direction, menu) {
					const items = menu.items;
					const newIndex = index + direction;
					if (newIndex < 0 || newIndex >= items.length || newIndex === index) return;
					if (!items[newIndex][2].isLevel) return;
					items.splice(index, 1);
					items.splice(newIndex, 0, this);
					saveLevels();
					return direction;
				},
				isLevel: true,
			}];
		}
		const items = levels.map(levelItem);
		items.unshift(MenuOption.back, ["New Level...", (menu) => {
			const name = prompt("Name?");
			if (!name) return true;
			
			let oldLevel = level;
			let oldTilemap = tilemap;
			
			tmh = 15;
			tmw = 25;
			level = {name, tilemap: []};
			genLevel("flat", true);
			
			levels.push(level);
			saveLevels();
			menu.items.push(levelItem(level));
			
			level = oldLevel;
			tilemap = oldTilemap;
			return true;
		}]);
		return items;
	};
	
	let isFullscreen = false;
	let onTitle = false;
	function enterPause() {
		pauseSubmenu(editor ? Menu.pauseEditor : Menu.pause);
	}
	function exitPause() {
		paused = false;
		pauseMenus.length = 0;
	}
	function drawPause() {
		if (!onTitle) {
			ctx.fillStyle = "black";
			ctx.globalAlpha = 0.5;
			ctx.fillRect(0, 0, sw, sh)
			ctx.globalAlpha = 1;
		}
		
		let cx = 16;
		let cy = 16;
		ctx.fillStyle = "white";
		ctx.textAlign = "left";
		ctx.textBaseline = "top";
		
		const menu = pauseMenus[pauseMenus.length - 1];
		
		if (onTitle) {
			ctx.font = "bold 42px sans-serif";
			ctx.fillText(
				"CST Contemporary:",
				cx, cy, sw
			);
			ctx.font = "16px sans-serif";
			ctx.fillText(
				"Not Really a Game, Just His Random Engine Experiments",
				cx + 140, cy + 43, sw
			);
			cy += 64;
		}
		
		for (let _i in menu.items) {
			const i = +_i;
			const fontSize = 28;
			if (menu.index !== i) {
				ctx.font = fontSize + "px sans-serif";
			} else {
				ctx.font = "bold "+fontSize+"px sans-serif";
			}
			ctx.fillStyle = "white";
			
			let item = menu.items[i];
			let text = item[0];
			if (typeof text !== "string") text = text();
			let prefix = "  ";
			if (menu.index === i) {
				if (item[2] && item[2].onSort && pressed("control")) {
					prefix = "= ";
					ctx.fillStyle = "yellow";
				} else {
					prefix = "> ";
				}
			}
			
			ctx.fillText(
				prefix + text,
				cx, cy, sw - cx*2
			);
			cy += fontSize;
		}
		
		if (menu.items[menu.index][2] && menu.items[menu.index][2].onSort) {
			ctx.font = "16px sans-serif";
			ctx.fillStyle = "white";
			ctx.textAlign = "left";
			ctx.textBaseline = "bottom";
			ctx.fillText(
				"Ctrl+Up/Down to sort.",
				8, sh-8, sw-16
			);
		} else if (menu.definition === Menu.pauseEditor) {
			const text = `Arrow keys/middle click drag/scroll: Move around
Left click: Place objects
Right click: Move objects
Middle click tap: Pick objects
1/2: Cycle objects
0: Playtest`;
			const fontSize = 16;
			ctx.font = fontSize + "px sans-serif";
			ctx.fillStyle = "white";
			ctx.textAlign = "left";
			ctx.textBaseline = "bottom";
			
			const split = text.split("\n");
			const yOrigin = sh - 8 - ((split.length - 1) * fontSize);
			for (let i = 0; i < split.length; i++) {
				ctx.fillText(
					split[i],
					8, yOrigin + i * fontSize, sw-16
				);
			}
		}
	}
	function stepPause() {
		const menu = pauseMenus[pauseMenus.length - 1];
		function clampIndex() {
			menu.index = Math.max(Math.min(menu.index, menu.items.length - 1), 0);
		}
		if (justPressed("up")) {
			let item = menu.items[menu.index];
			if (pressed("control") && item[2].onSort) {
				menu.index += item[2].onSort.call(item, menu.index, -1, menu) || 0;
			} else {
				menu.index--;
			}
		}
		clampIndex();
		if (justPressed("down")) {
			let item = menu.items[menu.index];
			if (pressed("control") && item[2].onSort) {
				menu.index += item[2].onSort.call(item, menu.index, 1, menu) || 0;
			} else {
				menu.index++;
			}
		}
		clampIndex();
		if (justPressed("enter") || justPressed("spacebar") || (!menu.inescapable && justPressed("esc"))) {
			if (justPressed("esc")) menu.index = 0;
			let returnVal = menu.items[menu.index][1];
			if (returnVal instanceof Function) returnVal = returnVal(menu);
			if (paused) {
				if (!returnVal) {
					pauseMenus.pop();
				} else if (returnVal === "back") {
					const index = pauseMenus.indexOf(menu);
					if (index >= 0) pauseMenus.splice(index, 1);
				}
				if (!pauseMenus.length) exitPause();
			}
		}
	}
	
	function titleScreen() {
		onTitle = true;
		editor = false;
		deleteAllObjs();
		level = null;
		tmw = 1;
		tmh = 1;
		genLevel();
		
		exitPause();
		pauseSubmenu(Menu.title);
	}
	function startGame(playtest = false) {
		onTitle = false;
		deleteAllObjs();
		camX = 0;
		camY = 0;
		
		if (editor) {
			objs.push(new Editor());
		} else {
			if (playtest) {
				objs.push(new Playtest());
				// stone sim stuff
				//tmw = 50;
				//tmh = lengthHeights[gameLength];
				//genLevel("random");
			}
			
			for (let y = 0; y < tmh; y++) for (let x = 0; x < tmw; x++) {
				const tl = tilemap[y][x];
				if (tl && tilesIndexed[tl] && tilesIndexed[tl].object) {
					tilemap[y][x] = 0;
					const obj = new tilesIndexed[tl].object();
					if (obj.spawnAt) obj.spawnAt(x * TILE_SIZE, y * TILE_SIZE);
					objs.push(obj);
				}
			}
		}
	}
	
	
	let loadedAssets = 0;
	let allAssets = 0;
	const loadErrors = [];
	function drawLoadingScreen() {
		ctx.save();
		ctx.scale(gameScale, gameScale);
		ctx.clearRect(0, 0, sw, sh);
		ctx.fillStyle = "white";
		ctx.textAlign = "left";
		ctx.textBaseline = "top";
		ctx.font = "bold 24px sans-serif";
		
		let loadingText = "";
		
		if (loadedAssets !== allAssets) {
			loadingText += "Loading... (" + loadedAssets + "/" + allAssets + ")\n";
		}
		loadErrors.forEach(function(err) {
			loadingText += err + "\n";
		});
		
		let cx = 24;
		let cy = 24;
		const lines = loadingText.split("\n");
		lines.forEach(function(line) {
			ctx.fillText(
				line,
				cx, cy
			);
			cy += 24;
		});
		ctx.restore();
	}
	
	function imgPromise(src) {
		return new Promise((res, rej) => {
			const img = new Image();
			img.src = src;
			img.onload = function() {
				res(img);
			};
			img.onerror = function(e) {
				rej(e);
			};
		});
	}
	
	function addSpriteSheet(assetName,json, sheetImage) {
		const sheetDef = new SpriteSheetDef();
		sheetDef.name = assetName;
		assets[assetName] = sheetDef;
		
		let ogx = 0;
		let ogy = 0;
		if (json.meta && json.meta.slices) {
			for (const slice of json.meta.slices) {
				if (slice.name !== "origin") continue;
				if (!slice.keys[0]) continue;
				ogx = slice.keys[0].bounds.x;
				ogy = slice.keys[0].bounds.y;
			}
		}
		
		const tags = (json.meta && json.meta.frameTags) || [];
		sheetDef.defineTag("");
		for (const tag of tags) {
			if (tag.direction !== "forward") throw new Error(`Tag directions other than forward are not supported yet (direction ${tag.direction} for ${tag.name})`);
			sheetDef.defineTag(tag.name, tag.repeat);
		}
		
		let i = 0;
		for (let [frameName, frame] of Object.entries(json.frames)) {
			if (frame.filename) frameName = frame.filename;
			if (frame.rotated) throw new Error("we need to handle rotated frames because of: " + frameName);
			const def = new SpriteDef(
				sheetImage, ogx - frame.spriteSourceSize.x, ogy - frame.spriteSourceSize.y,
			);
			def.imageX = frame.frame.x;
			def.imageY = frame.frame.y;
			def.imageWidth = frame.spriteSourceSize.w;
			def.imageHeight = frame.spriteSourceSize.h;
			def.canvasWidth = frame.sourceSize.w
			def.canvasHeight = frame.sourceSize.h
			def.canvasOriginX = ogx;
			def.canvasOriginY = ogy;
			if (frameName) assets[frameName] = def;
			
			sheetDef.checkTag("").addFrame(def);
			for (const tag of tags) {
				if (tag.from <= i && i <= tag.to) {
					sheetDef.checkTag(tag.name).addFrame(def);
				}
			}
			i++;
		}
		
		function parseData(value, type) {
			if (type === "number") return +value;
			else if (type === "boolean") return !!value && value !== "false";
			return value.toString();
		}
		
		if (json.meta && json.meta.layers) {
			const frames = sheetDef.checkTag("").frames;
			for (const layer of json.meta.layers) {
				if (!layer.name.startsWith("data:")) continue;
				const name = layer.name.substring("data:".length);
				
				let type = layer.data;
				if (!type) type = "string";
				let defaultValue = undefined;
				
				const equalsIndex = type.indexOf("=");
				if (equalsIndex >= 0) {
					defaultValue = type.substring(equalsIndex + 1);
					type = type.substring(0, equalsIndex);
					defaultValue = parseData(defaultValue, type);
				}
				for (const cel of layer.cels) {
					if (cel.data) frames[cel.frame].data[name] = parseData(cel.data, type);
				}
			}
		}
	}
	
	const baseDir = "./assets/";
	Object.keys(assets).forEach(async function(assetName) {
		allAssets++;
		const val = assets[assetName];
		
		let thisLoaded = false;
		function loadedAsset() {
			if (thisLoaded) return;
			thisLoaded = true;
			loadedAssets++;
			draw();
			if (loadedAssets === allAssets && !loadErrors.length) {
				titleScreen();
				loading = false;
				canvas.style.background = "#115";
				requestAnimationFrame(step);
			}
		}
		function loadFailed(e) {
			if (thisLoaded) return;
			thisLoaded = true;
			loadedAssets++;
			console.error("Could not load " + assetName + ": ", e);
			loadErrors.push(
				"Could not load " + assetName + "."
			);
			draw();
		}
		
		if (typeof val === "object" && val.sheet) {
			// Load a spritesheeet
			delete assets[assetName];
			const sheetJson = baseDir + val.sheet + ".json";
			const sheetPng = baseDir + val.sheet + ".png";
			
			Promise.all([
				fetch(sheetJson).then(res => {
					if (res.ok) return res.json();
					throw res.status + " " + res.statusText;
				}),
				imgPromise(sheetPng),
			]).then(([json, sheetImage]) => {
				addSpriteSheet(assetName, json, sheetImage);
				loadedAsset();
			}).catch(loadFailed);
		} else {
			const filename = baseDir + assetName + ".png";
			const img = new Image();
			img.src = filename;
			img.onload = function() {
				const args = Array.isArray(val) ? val : [];
				assets[assetName] = new SpriteDef(img, ...args);
				loadedAsset();
			};
			img.onerror = function(e) {
				loadFailed(e);
			};
		}
	});
	
	window.onresize = resizeGame;
	gameContainer.style = "display: grid; width: 100%; height: 100%; place-items: center;";
	document.documentElement.style.margin = "0";
	document.body.style.margin = "0";
	//document.body.style.overflow = "none";
	document.documentElement.style.width = "100%";
	document.documentElement.style.height = "100%";
	document.body.style.width = "100%";
	document.body.style.height = "100%";
	canv.style.minWidth = "0";
	canv.style.minHeight = "0";
	canv.style.maxWidth = "100%";
	canv.style.maxHeight = "100%";
	resizeGame();
	draw();
	
</script>
</html>