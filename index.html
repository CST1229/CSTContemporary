<!DOCTYPE html>
<html>
<head>
	<title>CST Cont.</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1"> 
	<link rel="icon" href="./assets/icon.ico">
</head>

<style>
	body {
		background: #050530;
		color: white;
	}
</style>

<center id="gameContainer">
	<noscript>you need javascript!</noscript>
	<canvas width="800" height="600" id="canvas">game</canvas>
</center>

<script>
	const DEBUG = true;
	
	// the game itself
	
	// Assets and constants
	// assets are filled in with Images by the loader
	const assets = {
		player1: 0,
		player2: 0,
		player3: 0,
		player4: 0,
		errortile: 0,
	};
	const tile = {
		none: 0,
		tile: 1,
		unbreakable: 2,
		gold: 3,
	};
	const MAX_TILES = Math.max(...Object.values(tile));
	for (let i = 1; i <= MAX_TILES; i++) {
		assets["tile" + i] = 0;
	}
	
	
	// utility functions
	const flr = Math.floor;
	const flrto = function(val, to) {
		return flr(val / to) * to;
	};
	const approach = function(from, to, rate) {
		if (from > to) return Math.max(from - rate, to);
		return Math.min(from + rate, to);
	};
	const sign = function(val) {
		return val > 0 ? 1 : (val < 0 ? -1 : 0);
	};
	const clamp = (val, min, max) => Math.max(min, Math.min(val, max));
	const ceil = Math.ceil;
	
	
	// Canvas stuff
	const gameContainer = document.getElementById("gameContainer");
	const canv = document.getElementById("canvas");
	const sw = 640;
	const sh = 480;
	let gameScale = 1;
	let gameScaleInverse = 1;
	canv.style.background = "black";
	
	const ctx = canv.getContext("2d");
	let resizedThisFrame = false;
	function resizeGame() {
		if (resizedThisFrame) return;
		const w = window.innerWidth;
		const h = window.innerHeight;
		if (w / h > sw / sh) {
			gameScale = Math.max(h / sh, 1);
			canv.style.width = "auto";
			canv.style.height = "100%";
		} else {
			gameScale = Math.max(w / sw, 1);
			canv.style.width = "100%";
			canv.style.height = "auto";
		}
		gameScale *= window.devicePixelRatio || 1;
		resizedThisFrame = true;
		canv.width = ceil(sw * gameScale);
		canv.height = ceil(sh * gameScale);
		draw();
		ctx.msImageSmoothingEnabled = false;
		ctx.imageSmoothingEnabled = false;
		gameScaleInverse = 1 / gameScale;
	}
	
	
	// Input
	const buttons = new Set();
	const buttonsJust = new Set();
	const modernKeyToIEKey = {
		arrowup: "up",
		arrowdown: "down",
		arrowleft: "left",
		arrowright: "right",
		" ": "spacebar",
		escape: "esc",
		
		// screw it i'll add wasd mappings here
		w: "up",
		a: "left",
		s: "down",
		d: "right",
	};
	const ignoreKeys = {
		"tab": true,
		"f1": true,
		"f2": true,
		"f3": true,
		"f4": true,
		"f5": true,
		"f6": true,
		"f7": true,
		"f8": true,
		"f9": true,
		"f10": true,
		"f11": true,
		"f12": true,
	};
	document.onkeydown = function(e) {
		const _key = e.key.toLowerCase();
		const key = modernKeyToIEKey[_key] || _key;
		if (!document.activeElement || (document.activeElement.tagName !== "BODY" && document.activeElement.tagName !== "CANVAS" && document.activeElement.tagName !== "HTML") || ignoreKeys[key]) return;
		if (!pressed(key)) buttonsJust.add(key);
		buttons.add(key);
		if (!e.ctrlKey && !e.altKey) e.preventDefault();
	};
	document.onkeyup = function(e) {
		const _key = e.key.toLowerCase();
		const key = modernKeyToIEKey[_key] || _key;
		buttons.delete(key);
	};
	const pressed = buttons.has.bind(buttons);
	const justPressed = buttonsJust.has.bind(buttonsJust);
	
	let mouseX = null;
	let mouseY = null;
	function updateMouse(e) {
		const canvasRect = canvas.getBoundingClientRect();
		mouseX = flrto((e.clientX - canvasRect.x) / canvasRect.width * sw, 0.0001);
		mouseY = flrto((e.clientY - canvasRect.y) / canvasRect.height * sh, 0.0001);
		
		const lmb = e.buttons & 0b1;
		const rmb = e.buttons & 0b10;
		const mmb = e.buttons & 0b100;
		if (lmb && !buttons.has("lmb")) buttonsJust.add("lmb");
		if (rmb && !buttons.has("rmb")) buttonsJust.add("rmb");
		if (mmb && !buttons.has("mmb")) buttonsJust.add("mmb");
		buttons[lmb ? "add" : "delete"]("lmb");
		buttons[rmb ? "add" : "delete"]("rmb");
		buttons[mmb ? "add" : "delete"]("mmb");
	}
	window.addEventListener("mousedown", updateMouse);
	window.addEventListener("mouseup", updateMouse);
	window.addEventListener("mousemove", updateMouse);
	canvas.addEventListener("contextmenu", (e) => e.preventDefault());
	
	
	// Level generation
	// fill an array
	function fill(arr, val) {
		for (let i = 0; i < arr.length; i++) arr[i] = val;
		return arr;
	}
	const TILE_SIZE = 32;
	const GEN_FACTOR = 300;
	const GEN_YOFF = 400;
	
	let editor = false;
	let tmh = 200; // tilemap height
	let tmw = 150; // tilemap width
	let tilemap;
	let gameLength = "Medium";
	function genLevel(type) {
		if (type === "random")
			tilemap = fill(new Array(tmh)).map(function(v, i) {
				return fill(new Array(tmw)).map(function() {
					if (i > 0) return Math.floor(Math.random() * (i + GEN_YOFF) / GEN_FACTOR) ? tile.tile : tile.none;
					return tile.none;
				});
			});
		else if (type === "flat")
			tilemap = fill(new Array(tmh)).map(function(v, i) {
				return fill(new Array(tmw)).map(function() {
					if (i < (tmh - 1)) return tile.none;
					return tile.tile;
				});
			});
		else
			tilemap = fill(new Array(tmh)).map(function(v, i) {
				return fill(new Array(tmw), tile.none);
			});
	}
	const lengthHeights = {
		Tiny: 50,
		Short: 100,
		Medium: 200,
		Long: 250,
		XL: 300,
	};
	const gameTimes = {
		Tiny: 10,
		Short: 30,
		Medium: 70,
		Long: 100,
		XL: 135,
	};
	const gameLengths = Object.keys(lengthHeights);
	
	
	// Level storage
	let levels = [];
	levels.push({name: "Test Level",
		tilemap: [[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[1,1,1,1,1]]
	});
	try {
		const levArr = JSON.parse(localStorage.getItem("levels"));
		if (Array.isArray(levArr)) levels = levArr;
	} catch(e) {}
	
	function saveLevels() {
		saveLevel();
		localStorage.setItem("levels", JSON.stringify(levels));
	}
	let level = null;
	function saveLevel() {
		if (!level || !tilemap) return;
		level.tilemap = structuredClone(tilemap);
	}
	function loadLevel(lvl) {
		level = lvl;
		tmh = lvl.tilemap.length;
		tmw = (lvl.tilemap[0] || []).length;
		tilemap = structuredClone(lvl.tilemap);
	}
	
	// Tile utils
	// world x, world y
	function tileAt(wx, wy, oobTile) {
		const tx = flr(wx / TILE_SIZE);
		const ty = flr(wy / TILE_SIZE);
		return getTile(tx, ty, oobTile);
	}
	function tileInBounds(tx, ty) {
		if (ty < 0 || ty >= tmh) return false;
		if (tx < 0 || tx >= tmw) return false;
		return true
	}
	function getTile(tx, ty, oobTile) {
		if (!tileInBounds(tx, ty)) return oobTile;
		return tilemap[ty][tx];
	}
	function setTile(tx, ty, tile) {
		if (!tileInBounds(tx, ty)) return undefined;
		return tilemap[ty][tx] = tile;
	}
	
	
	// Objects
	const objs = [];
	function deleteAllObjs() {
		objs.forEach(o => {
			if (o.dispose) o.dispose();
		});
		objs.length = 0;
	}
	function deleteObj(o) {
		if (o.dispose) o.dispose();
		const index = objs.indexOf(o);
		if (index >= 0) objs.splice(index, 1);
	}
	
	function Player(timer) {
		this.x = 0;
		this.y = 0;
		this.hsp = -0.1;
		this.vsp = 0;
		this.falling = 0;
		
		this.jumpBuffer = 0;
		this.storedBlock = 0;
		
		this.facing = 1;
		
		const grav = 1200;
		const accel = 800;
		const decel = 3000;
		const friction = 800;
		const jumpSpeed = -500;
		const maxSpeed = 300;
		const w = 24;
		const h = 24;
		
		if (timer) timer.player = this;
		
		this.step = function(dt) {
			const joystickX = pressed("right") - pressed("left");
			
			if (joystickX !== 0) {
				if (joystickX === -sign(this.hsp))
					this.hsp += joystickX * decel * dt;
				else
					this.hsp += joystickX * accel * dt;
				this.facing = joystickX;
			} else
				this.hsp = approach(this.hsp, 0, friction * dt);
			
			this.vsp += grav * dt;
			this.hsp = Math.min(Math.max(this.hsp, -maxSpeed), maxSpeed);
			
			this.y += this.vsp * dt;
			this.falling += dt;
			if (this.vsp > 0 && (
				tileAt(this.x, this.y + h, tile.unbreakable) ||
				tileAt(this.x + w - 0.01, this.y + h, tile.unbreakable)
			)) {
				this.y = flrto(this.y + h, TILE_SIZE) - h;
				this.vsp = 0;
				this.falling = 0;
			} else if (this.vsp < 0 && tileAt(this.x + w/2, this.y, tile.unbreakable)) {
				this.y = flrto(this.y, TILE_SIZE) + TILE_SIZE;
				this.vsp = 0;
			}
			this.x += this.hsp * dt;
			if (this.hsp <= 0 && tileAt(this.x, this.y + h/2, tile.unbreakable)) {
				this.x = flrto(this.x, TILE_SIZE) + TILE_SIZE;
				this.hsp = 0;
			} else if (this.hsp >= 0 && tileAt(this.x + w, this.y + h/2, tile.unbreakable)) {
				this.x = flrto(this.x + w, TILE_SIZE) - w;
				this.hsp = 0;
			}
			
			if (justPressed("up")) this.jumpBuffer = 0.1;
			if (this.falling <= 0.2 && this.jumpBuffer > 0) {
				this.falling = 999;
				this.jumpBuffer = 0;
				this.vsp = jumpSpeed;
			}
			this.jumpBuffer = approach(this.jumpBuffer, 0, dt);
			
			
			if (justPressed("spacebar")) {
				const tx = flr((this.x + w/2) / TILE_SIZE);
				const ty = ceil((this.y + h/2) / TILE_SIZE);
				const blockBoost = DEBUG && pressed("down");
				if (this.storedBlock > 0) {
					if (!getTile(tx, ty, tile.unbreakable) || (blockBoost && getTile(tx, ty, tile.unbreakable) != tile.unbreakable)) {
						if (blockBoost && getTile(tx, ty, tile.unbreakable)) {
							setTile(tx, ty, tile.none);
							this.vsp = jumpSpeed * Math.sqrt(2);
						} else
							setTile(tx, ty, this.storedBlock);
						this.storedBlock = 0;
					} else if (!getTile(tx, ty - 1, tile.unbreakable) && !getTile(tx, ty - 2, tile.unbreakable)) {
						setTile(tx, ty - 1, this.storedBlock);
						this.storedBlock = 0;
						// snap to the block we just placed
						this.y = (ty - 1) * TILE_SIZE - h;
					}
				} else if (this.falling == 0) {
					const tl = getTile(tx, ty);
					if (tl && tl != tile.unbreakable) {
						this.storedBlock = tl;
						setTile(tx, ty, tile.none);
						this.falling = 999;
					}
				}
			}
			
			camX = this.x + w/2 - sw/2;
			camY = this.y + h/2 - sh/2;
			
			if (this.y >= (tmh * TILE_SIZE - h)) {
				deleteObj(this);
				if (timer) timer.stopped = true;
				objs.push(new WinText());
			}
			if (justPressed("0")) {
				queueMicrotask(() => {
					editor = true;
					loadLevel(level);
					startGame();
				});
			}
		};
		this.draw = function(ctx) {
			if (this.storedBlock) {
				ctx.drawImage(tileGraphic(this.storedBlock), -4, -26, 32, 32);
			}
			
			let frame = (this.facing === 1 ? 1 : 2);
			if (this.storedBlock) frame += 2;
			ctx.drawImage(assets["player" + frame], -4, -8, 32, 32);
		};
	}
	function WinText() {
		this.drawGUI = function(ctx) {
			ctx.fillStyle = "white";
			ctx.textAlign = "center";
			ctx.textBaseline = "top";
			ctx.font = "bold 64px sans-serif";
			
			ctx.fillText(
				"You Have Not Win!",
				sw/2, sh/2-48
			);
			ctx.font = "32px sans-serif";
			ctx.fillText(
				"(You... DIED!!!)",
				sw/2, sh/2+16
			);
		};
	}
	function Timer() {
		this.time = 0;
		this.stopped = false;
		this.player = null;
		
		this.step = function(dt) {
			if (!this.stopped) this.time += dt;
		};
		this.drawGUI = function(ctx) {
			ctx.fillStyle = "white";
			ctx.textAlign = "center";
			ctx.textBaseline = "top";
			ctx.font = "32px sans-serif";
			
			ctx.fillText(
				this.time.toFixed(3).toString(),
				sw/2, 16
			);
			
			if (this.player) {
				const PROGRESS_WIDTH = 12;
				if (!this.stopped) {
					ctx.globalAlpha = this.player.x > 16 ? 1 : 0.25;
					
					// split in 2 for proper transparency
					const playerY = flrto(this.player.y / (tmh * TILE_SIZE) * sh, gameScaleInverse);
					ctx.fillStyle = "black"
					ctx.fillRect(0, 0, PROGRESS_WIDTH, playerY);
					ctx.fillRect(0, playerY + PROGRESS_WIDTH, PROGRESS_WIDTH, sh - playerY);
					
					ctx.fillStyle = "#639bff";
					ctx.fillRect(0, playerY, PROGRESS_WIDTH, PROGRESS_WIDTH);
				} else {
					ctx.fillStyle = "black";
					ctx.fillRect(0, 0, PROGRESS_WIDTH, sh);
				}
			}
		};
	}
	function Editor() {
		let scrolledX = 0;
		let scrolledY = 0;
		let lastMouseX = mouseX;
		let lastMouseY = mouseY;
		let couldPick = false;
		
		let brush = tile.tile;
		
		// 2-finger touch scrolling, mainly
		function onScroll(e) {
			if (paused) return;
			scrolledX += e.deltaX / gameScale;
			scrolledY += e.deltaY / gameScale;
		}
		canvas.addEventListener("wheel", onScroll);
		
		const moveSpeed = TILE_SIZE * 15;
		this.step = function(dt) {
			const joystickX = pressed("right") - pressed("left");
			const joystickY = pressed("down") - pressed("up");
			camX += joystickX * dt * moveSpeed + scrolledX;
			camY += joystickY * dt * moveSpeed + scrolledY;
			if (mouseX != null && mouseY != null && pressed("mmb")) {
				if (lastMouseX - mouseX != 0 || lastMouseY - mouseY != 0) couldPick = false;
				camX += lastMouseX - mouseX;
				camY += lastMouseY - mouseY;
			}
			[camX, camY] = getClampedCameraPos(false);
			scrolledX = 0;
			scrolledY = 0;
			lastMouseX = mouseX;
			lastMouseY = mouseY;
			
			if (justPressed("1")) brush--;
			if (justPressed("2")) brush++;
			brush = clamp(brush, 1, MAX_TILES);
			
			if (pressed("lmb") || pressed("rmb")) {
				couldPick = false;
				const tl = pressed("rmb") ? tile.none : brush;
				const [cx, cy] = getClampedCameraPos();
				const tx = flr((cx + mouseX) / TILE_SIZE);
				const ty = flr((cy + mouseY) / TILE_SIZE);
				setTile(tx, ty, tl);
			}
			
			if (justPressed("0")) {
				queueMicrotask(() => {
					editor = false;
					saveLevels();
					startGame();
				});
			}
		};
		
		this.draw = function() {
			if (!pressed("rmb") && !pressed("lmb") && !pressed("mmb")) {
				const [cx, cy] = getClampedCameraPos();
				const tx = flr((cx + mouseX) / TILE_SIZE);
				const ty = flr((cy + mouseY) / TILE_SIZE);
				ctx.globalAlpha = 0.5;
				ctx.drawImage(tileGraphic(brush), tx * TILE_SIZE, ty * TILE_SIZE, 32, 32);
			}
		};
		
		this.dispose = function() {
			canvas.removeEventListener("scroll", onScroll);
		};
	}
	
	function getClampedCameraPos(rounded = true) {
		const borderW = editor ? sw/2 : 0;
		const borderH = editor ? sh/2 : 0;
		
		let eCamX = Math.min(camX, Math.max(tmw * TILE_SIZE - sw, 0) + borderW);
		let eCamY = Math.min(camY, Math.max(tmh * TILE_SIZE - sh, 0) + borderH);
		if (rounded) {
			eCamX = flrto(eCamX, gameScaleInverse);
			eCamY = flrto(eCamY, gameScaleInverse);
		}
		eCamX = Math.max(eCamX, -borderW);
		eCamY = Math.max(eCamY, -borderH);
		return [eCamX, eCamY];
	}
	
	function tileGraphic(tile) {
		return assets["tile" + tile] || assets.errortile;
	}
	
	let camX = 0;
	let camY = 0;
	let loading = true;
	function draw(dt) {
		if (loading) return drawLoadingScreen();
		ctx.save();
		ctx.scale(gameScale, gameScale);
		ctx.clearRect(0, 0, sw, sh);
		ctx.save();
		try {
			// effective camera position
			const [eCamX, eCamY] = getClampedCameraPos();
			ctx.translate(-eCamX, -eCamY);
			
			// level border
			if (editor && !onTitle) {
				ctx.fillStyle = "#000";
				ctx.globalAlpha = 0.25;
				
				const bw = sw*2;
				const bh = sh*2;
				ctx.fillRect(-bw, -bh, bw, tmh * TILE_SIZE + bh * 2); // left
				ctx.fillRect(0, -bh, tmw * TILE_SIZE, bh);  // top
				ctx.fillRect(tmw * TILE_SIZE, -bh, bw, tmh * TILE_SIZE + bh * 2); // right
				ctx.fillRect(0, tmh * TILE_SIZE, tmw * TILE_SIZE, bh);  // bottom
				
				ctx.globalAlpha = 1;
			}
			
			// tilemap
			ctx.fillStyle = "#448";
			let minx = flr(eCamX / TILE_SIZE, gameScaleInverse), maxx = minx + ceil(sw / TILE_SIZE) + 1;
			for (let miny = flr(eCamY / TILE_SIZE, gameScaleInverse), y = miny, maxy = miny + ceil(sh / TILE_SIZE) + 1 ; y < maxy; y++) {
				if (!tilemap[y]) continue;
				for (let x = minx; x < maxx; x++) {
					if (tilemap[y][x])
						ctx.drawImage(tileGraphic(tilemap[y][x]), x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE)
				}
			}
			
			objs.forEach(function(obj) {
				if (obj.draw) {
					ctx.save();
					if ("x" in obj) ctx.translate(flrto(+obj.x, gameScaleInverse), flrto(+obj.y, gameScaleInverse))
					obj.draw(ctx);
					ctx.restore();
				}
			});
			objs.forEach(function(obj) {
				if (obj.drawGUI) {
					obj.drawGUI(ctx);
				}
			});
		} catch(e) {
			throw e;
		} finally {
			ctx.restore();
			if (DEBUG) {
				ctx.fillStyle = "white";
				ctx.textAlign = "left";
				ctx.textBaseline = "top";
				ctx.font = "11px sans-serif";
				const fps = (1 / dt).toFixed(1);
				ctx.fillText(
					"DEBUG - fps: " + fps,
					2, 2
				);
			}
		}
		if (paused) {
			drawPause();
		}
		ctx.restore();
	}
	
	let lastT = 0;
	const maxDelta = 1 / 10;
	function step(t) {
		const dt = Math.min((t - lastT) / 1000, maxDelta);
		lastT = t;
		
		if (paused) {
			stepPause();
		} else {
			objs.forEach(function(obj) {
				if (obj.step) obj.step(dt);
			});
			if (justPressed("enter") || justPressed("esc")) enterPause();
		}
		draw(dt);
		buttonsJust.forEach(function(bt) {
			buttonsJust.delete(bt);
		});
		requestAnimationFrame(step);
		resizedThisFrame = false;
	}
	
	
	let paused = false;
	let pauseMenus = [];
	function Menu(menu = []) {
		this.index = 0;
		this.inescapable = false;
		if (menu.items) {
			// this is a menu object
			Object.assign(this, menu);
		} else {
			this.items = menu;
		}
	}
	function pauseSubmenu(items = []) {
		if (!paused) pauseMenus.length = 0;
		paused = true;
		
		if (items instanceof Function) items = items();
		const menu = new Menu(items);
		pauseMenus.push(menu);
		return menu;
	}
	
	const MenuOption = {
		back: ["Back"],
		gameLength: [() => "Game Length: " + gameLength, () => {
			let index = gameLengths.indexOf(gameLength) + 1;
			if (index >= gameLengths.length) index = 0;
			gameLength = gameLengths[index];
			return true;
		}],
		levels: [() => onTitle ? "Level Editor..." : "Levels...", () => {
			saveLevels();
			return pauseSubmenu(Menu.levels);
		}],
		stoneSimulator: ["Stone Simulator...", () => pauseSubmenu([MenuOption.back, MenuOption.gameLength])],
	}
	
	Menu.title = {inescapable: true, items: [
		/*["Start", () => {
			editor = false;
			startGame(true);
		}],*/
		MenuOption.levels,
		//MenuOption.stoneSimulator,
		["Links...",
			() => pauseSubmenu([
				MenuOption.back,
				["Made by CST1229", () => {
					setTimeout(() => {
						window.open("https://cst1229.eu.org/", "_blank");
					}, 100);
					return true;
				}],
				["Source Code", () => {
					setTimeout(() => {
						window.open("https://github.com/CST1229/StoneSimulator/", "_blank");
					}, 100);
					return true;
				}],
				["Play CST Stone Simulator!", () => {
					setTimeout(() => {
						window.open("https://cst1229.github.io/StoneSimulator", "_blank");
					}, 100);
					return true;
				}],
			]),
		],
		["Quit", () => {
			window.close();
		}],
	]};
	Menu.pause = [
		["Continue"],
		/*["New Game", () => {
			startGame(true);
		}],*/
		["Edit (0)", () => {
			editor = true;
			startGame();
		}],
		MenuOption.levels,
		//MenuOption.stoneSimulator,
		["Exit", () => {
			saveLevels();
			titleScreen();
			return true;
		}],
	];
	Menu.pauseEditor = [
		["Continue"],
		["Playtest (0)", () => {
			editor = false;
			saveLevels();
			startGame();
		}],
		["Level Properties...", () => pauseSubmenu([
				MenuOption.back,
				[() => ("Level Name: " + ((level && level.name) ? level.name : "WHAT")), () => {
					const name = prompt("Name?", level.name);
					if (!name) return true;
					level.name = name;
					saveLevels();
					return true;
				}],
				["Resize Level", () => {
					const w = flr(+(prompt("Width...", tmw)) || 0);
					if (w <= 0 || !isFinite(w)) return true;
					const h = flr(+(prompt("Height...", tmh)) || 0);
					if (h <= 0 || !isFinite(h)) return true;
					if (h > tmh) {
						for (let i = tmh; i < h; i++) tilemap.push(fill(new Array(tmw), tile.none));
					} else if (h < tmh) {
						for (let i = tmh; i > h; i--) tilemap.pop();
					}
					if (w > tmw) {
						for (let i = tmw; i < w; i++) tilemap.forEach(t => t.push(tile.none));
					} else if (w < tmw) {
						for (let i = tmw; i > w; i--) tilemap.forEach(t => t.pop());
					}
					tmw = w;
					tmh = h;
					return true;
				}],
				["Clear Level", () => {
					if (confirm("Are you sure you want to clear this level?")) {
						genLevel();
						startGame();
					}
					return true;
				}],
				["Delete Level", () => {
					if (confirm("Are you sure you want to delete this level?")) {
						levels.splice(levels.indexOf(level), 1);
						level = null;
						saveLevels();
						titleScreen();
						return "back";
					}
					return true;
				}],
			]),
		],
		MenuOption.levels,
		["Exit", () => {
			titleScreen();
			return "back";
		}],
	];
	Menu.levels = () => {
		const items = levels.map(l => [l.name, () => {
			editor = true;
			loadLevel(l);
			startGame();
			exitPause();
		}]);
		items.unshift(MenuOption.back, ["New Level...", () => {
			const name = prompt("Name?");
			if (!name) return true;
			queueMicrotask(() => {
				editor = true;
				exitPause();
				
				tmh = 15;
				tmw = 25;
				
				level = {name, tilemap: []};
				genLevel("flat");
				
				levels.push(level);
				saveLevels();
				startGame();
			});
		}]);
		return items;
	};
	
	let isFullscreen = false;
	let onTitle = false;
	function enterPause() {
		pauseSubmenu(editor ? Menu.pauseEditor : Menu.pause);
	}
	function exitPause() {
		paused = false;
		pauseMenus.length = 0;
	}
	function drawPause() {
		let cx = 16;
		let cy = 16;
		ctx.fillStyle = "white";
		ctx.textAlign = "left";
		ctx.textBaseline = "top";
		
		const menu = pauseMenus[pauseMenus.length - 1];
		
		if (onTitle) {
			ctx.font = "bold 48px sans-serif";
			ctx.fillText(
				"CST Contemporary",
				cx, cy, sw
			);
			cy += 64;
		}
		
		for (let _i in menu.items) {
			const i = +_i;
			const fontSize = 28;
			if (menu.index !== i) {
				ctx.font = fontSize + "px sans-serif";
			} else {
				ctx.font = "bold "+fontSize+"px sans-serif";
			}
			let text = menu.items[i][0];
			if (typeof text !== "string") text = text();
			ctx.fillText(
				(menu.index === i ? "> " : "  ") +
				text,
				cx, cy, sw - cx*2
			);
			cy += fontSize;
		}
	}
	function stepPause() {
		const menu = pauseMenus[pauseMenus.length - 1];
		if (justPressed("up"))
			menu.index = Math.max(menu.index - 1, 0);
		if (justPressed("down"))
			menu.index = Math.min(menu.index + 1, menu.items.length - 1);
		if (justPressed("enter") || justPressed("spacebar") || (!menu.inescapable && justPressed("esc"))) {
			if (justPressed("esc")) menu.index = 0;
			let returnVal = menu.items[menu.index][1];
			if (returnVal instanceof Function) returnVal = returnVal();
			if (paused) {
				if (!returnVal) {
					pauseMenus.pop();
				} else if (returnVal === "back") {
					const index = pauseMenus.indexOf(menu);
					if (index >= 0) pauseMenus.splice(index, 1);
				}
				if (!pauseMenus.length) exitPause();
			}
		}
	}
	
	function titleScreen() {
		onTitle = true;
		editor = false;
		deleteAllObjs();
		level = null;
		tmw = 1;
		tmh = 1;
		genLevel();
		
		pauseSubmenu(Menu.title);
	}
	function startGame(stoneSim = false) {
		onTitle = false;
		deleteAllObjs();
		camX = 0;
		camY = 0;
		
		if (editor) {
			objs.push(new Editor());
		} else {
			let timer;
			if (stoneSim) {
				timer = new Timer();
				tmw = 50;
				tmh = lengthHeights[gameLength];
				genLevel("random");
			}
			objs.push(new Player(timer));
			if (timer) objs.push(timer);
		}
	}
	
	
	let loadedAssets = 0;
	let allAssets = 0;
	const loadErrors = [];
	function drawLoadingScreen() {
		ctx.save();
		ctx.scale(gameScale, gameScale);
		ctx.clearRect(0, 0, sw, sh);
		ctx.fillStyle = "white";
		ctx.textAlign = "left";
		ctx.textBaseline = "top";
		ctx.font = "bold 24px sans-serif";
		
		let loadingText = "";
		
		if (loadedAssets !== allAssets) {
			loadingText += "Loading... (" + loadedAssets + "/" + allAssets + ")\n";
		}
		loadErrors.forEach(function(err) {
			loadingText += err + "\n";
		});
		
		let cx = 24;
		let cy = 24;
		const lines = loadingText.split("\n");
		lines.forEach(function(line) {
			ctx.fillText(
				line,
				cx, cy
			);
			cy += 24;
		});
		ctx.restore();
	}
	
	Object.keys(assets).forEach(function(key) {
		allAssets++;
		const filename = "./sprites/" + key + ".png";
		const img = new Image();
		img.src = filename;
		assets[key] = img;
		img.onload = function() {
			loadedAssets++;
			draw();
			if (loadedAssets === allAssets && !loadErrors.length) {
				titleScreen();
				loading = false;
				canvas.style.background = "#115";
				requestAnimationFrame(step);
			}
		};
		img.onerror = function(e) {
			loadedAssets++;
			loadErrors.push(
				"Could not load " + filename + "."
			);
			draw();
		};
	});
	
	window.onresize = resizeGame;
	gameContainer.style = "display: grid; width: 100%; height: 100%; place-items: center;";
	document.documentElement.style.margin = "0";
	document.body.style.margin = "0";
	//document.body.style.overflow = "none";
	document.documentElement.style.width = "100%";
	document.documentElement.style.height = "100%";
	document.body.style.width = "100%";
	document.body.style.height = "100%";
	canv.style.minWidth = "0";
	canv.style.minHeight = "0";
	canv.style.maxWidth = "100%";
	canv.style.maxHeight = "100%";
	resizeGame();
	draw();
	
</script>
</html>